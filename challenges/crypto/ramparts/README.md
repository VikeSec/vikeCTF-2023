# Ramparts, Shields & Armour

**Author: [`Kyle Stang`](https://github.com/kylestang)**

**Category: `Crypto Medium`**

## Description

We vikings defend our villages and our precious flags with our lives. Our ramparts, shields & armour cannot be broken. We've built them with our own hands, and we'll laugh at your puny attempts to crack them.

## Organizers

Users should receive a copy of `encrypt.py`, as well as the `e`, `n`, and `c` used in the challenge.

```console
$ python3 encrypt.py
Enter flag: vikeCTF{P1ckingPrim3sPrec@riou5ly}
e: 65537
n: 2715497625635217146051376883956221648457865424622390574119932619240972515957205301547292163268724150187299302534465552773073139476525066742321406599243867465883849966396559680643698047414084301014507492106282319588119157974394187603403699632895945629213903894587666324702695802895745447206685995668163896335087720970956472989601397590054003266898289768493161392030105302457157363021403799771182388703628329605850194393268686044923475312870917582827968692465970401385092167983959555898172994224835950025711275910795477467161659125090139213700951006615227142761425199562930474622208063719519967552546075441680528564381619671244482483370324691479133982575782792761354401433225302382110766631654057892534939319680412593946754663446176047443171302181260711497921957223797559705657563059146379524464376911709110980976711662094151747135752785623430700378782619219767151302618362874360951701711850602414797407445920937513222982463
c: 2412481553363067093994916106363138049676984068236717223446550136171994383803478397500582933716465596790399547785030492395365201877716652700143844505307501652470883697533651197665986331703230104426840112747699995620811385491528574446175126510676387450802481586396253826465171957105380668709916951820668574228024071014457042504788367209816822997439069546208655373188430319424281112336866266338808391138368420494075883526920594370234349115371071576557496658595306274879005581064161369194441884021024926550233457727353645678589032674268525692578834142222591657655876528245907018527470023673383681518369733877208435542662260811658693623152145931671636562104853620717919813146153890630297430942453932072766596242967505064809743305645874530813033758653920440104744594118679043088872558752784045628474230603822071828647953195345218722932560770485975541412563771196519749202050483658465939572153802085946092772315833898486765474763
```

## Solution

<details> 
  <summary><b>TLDR:</b> Spoiler Warning</summary>

> The primes chosen are too close together (within about 1,000,000 of each other) so `p`, `q`, and `r` can easily be found

</details>

Alright, we have a file called `encrypt.py`, and some numbers `e`, `n`, and `c`. Those variables should tip us off that this might be [RSA encryption](<https://en.wikipedia.org/wiki/RSA_(cryptosystem)>).

Reading `encrypt.py`, we can see that there's an encryption step and some helper functions. Let's focus on the encryption for now. First, the flag is read from stdin and stored in a variable. Then three 1024-bit prime numbers are created with `p, q, r = generate_primes(1024)` and multiplied together with `n = p*q*r`. Usually you only use 2 primes for RSA, so this seems a bit strange. Nonetheless, it looks like `n` is our RSA modulus. The rest of the encryption seems like bog-standard RSA, with output in the same format we were given.

So how can we break it?

A basic rule of RSA is that if you can factor the modulus `n`, you can decrypt the ciphertext. Asking sagemath to factor it doesn't work, unfortunately. Neither does [RsaCtfTool](https://github.com/RsaCtfTool/RsaCtfTool), usually a great resource for these things.

Let's look at those helper functions to see how the primes are being generated.

```python
def generate_primes(bits):
    seed = int.from_bytes(randbytes(bits // 8), byteorder="little")
    p = (seed + randint(-10e5, 10e5)) | 1
    while not is_prime(p):
        p += 2

    q = (seed + randint(-10e5, 10e5)) | 1
    while not is_prime(q):
        q += 2

    r = (seed + randint(-10e5, 10e5)) | 1
    while not is_prime(r):
        r += 2

    return p, q, r
```

Well that's interesting! It seems like our primes aren't completely random. Instead of generating 3 completely random numbers, `generate_primes` first creates a single large random number `seed`, and then creates all the primes as random offsets from that. So, `p`, `q`, and `r` should all be within about 1000000 of each other, a tiny difference as far as cryptography's concerned.

If we start testing from the cube root of `n`, we can find its factors fairly quickly. Let's create an integer root function write that up in python:

```python
def solve(n):
    p = iroot(3, n) | 1
    while n % p != 0:
        p -= 2

    n = n // p
    q = iroot(2, n) | 1
    while n % q != 0:
        q -= 2

    r = n // q

    return p, q, r
```

This starts at the cube root of `n` and keeps testing successive odd numbers until we find the first factor. Then we divide `n` by the factor, start from the square root of `n` and find the remaining factors. Now that we've successfully factored `n`, it's just standard RSA to derive the private key and decrypt the ciphertext.

```python
e = int(input("Enter exponent e: "))
n = int(input("Enter modulus n: "))
c = int(input("Enter ciphertext c: "))

p, q, r = solve(n)

λ_n = lcm(lcm(p - 1, q - 1), r - 1)
d = modular_multiplicative_inverse(e, λ_n)

m = pow(c, d, n)

flag = m.to_bytes((m.bit_length() + 7) // 8, byteorder="little").decode("utf8")
print(flag)
```

The full implementation can be found in `decrypt.py`.

```console
$ python3 decrypt.py
Enter exponent e: 65537
Enter modulus n: 2715497625635217146051376883956221648457865424622390574119932619240972515957205301547292163268724150187299302534465552773073139476525066742321406599243867465883849966396559680643698047414084301014507492106282319588119157974394187603403699632895945629213903894587666324702695802895745447206685995668163896335087720970956472989601397590054003266898289768493161392030105302457157363021403799771182388703628329605850194393268686044923475312870917582827968692465970401385092167983959555898172994224835950025711275910795477467161659125090139213700951006615227142761425199562930474622208063719519967552546075441680528564381619671244482483370324691479133982575782792761354401433225302382110766631654057892534939319680412593946754663446176047443171302181260711497921957223797559705657563059146379524464376911709110980976711662094151747135752785623430700378782619219767151302618362874360951701711850602414797407445920937513222982463
Enter ciphertext c: 2412481553363067093994916106363138049676984068236717223446550136171994383803478397500582933716465596790399547785030492395365201877716652700143844505307501652470883697533651197665986331703230104426840112747699995620811385491528574446175126510676387450802481586396253826465171957105380668709916951820668574228024071014457042504788367209816822997439069546208655373188430319424281112336866266338808391138368420494075883526920594370234349115371071576557496658595306274879005581064161369194441884021024926550233457727353645678589032674268525692578834142222591657655876528245907018527470023673383681518369733877208435542662260811658693623152145931671636562104853620717919813146153890630297430942453932072766596242967505064809743305645874530813033758653920440104744594118679043088872558752784045628474230603822071828647953195345218722932560770485975541412563771196519749202050483658465939572153802085946092772315833898486765474763
vikeCTF{P1ckingPrim3sPrec@riou5ly}
```

## Flag

```
vikeCTF{P1ckingPrim3sPrec@riou5ly}
```
